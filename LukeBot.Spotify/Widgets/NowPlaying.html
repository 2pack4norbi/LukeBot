<!DOCTYPE html>

<style>
    body {
        background-color: rgba(0, 0, 0, 0);
        margin: 0px;
        margin-left: 3px;
        overflow: hidden;
        white-space: nowrap;
        color: #ffffff;
        font: 48px Arial;
        text-shadow: black 0px 0px 2px, black 0px 0px 2px, black 0px 0px 2px, black 0px 0px 2px, black 0px 0px 2px;
        height: 100%;
    }

    #title {
    }

    #artists {
    }

    #label {
    }

    .field-margin {
        margin-right: 50px;
    }

    #debug {
        font: 16px Arial;
        white-space: normal;
        color: #ffffff;
    }
</style>

<div id="title">
    <span id="subTitleMain" class="field-margin">Title</span><span id="subTitleExtra"></span>
</div>
<div id="artists">
    <span id="subArtistsMain" class="field-margin">Artists</span><span id="subArtistsExtra"></span>
</div>
<div id="label">
    <span id="subLabelMain" class="field-margin">[Label]</span><span id="subLabelExtra"></span>
</div>
<!-- Debugging section - commented out in release code
<br />
<div>
    Debug logs:<br />
</div>
<div id="debug" class="debug">
</div>
-->

<script>
    const dbg = document.getElementById("debug");
    function printDebug(text) {
        if (dbg) {
            dbg.innerHTML += text + "<br />";
        }
    }

    const metadata = document.getElementsByTagName('meta');
    function getMeta(name) {
        for (let i = 0; i < metadata.length; ++i) {
            if (metadata[i].getAttribute('name') === name) {
                return metadata[i].getAttribute('content');
            }
        }
        return '';
    }

    const artists = document.getElementById('artists');
    const subArtistsMain = document.getElementById('subArtistsMain');
    const subArtistsExtra = document.getElementById('subArtistsExtra');
    let subArtistsMainStyle = window.getComputedStyle(subArtistsMain);

    const title = document.getElementById('title');
    const subTitleMain = document.getElementById('subTitleMain');
    const subTitleExtra = document.getElementById('subTitleExtra');
    let subTitleMainStyle = window.getComputedStyle(subTitleMain);

    const label = document.getElementById('label');
    const subLabelMain = document.getElementById('subLabelMain');
    const subLabelExtra = document.getElementById('subLabelExtra');
    let subLabelMainStyle = window.getComputedStyle(subLabelMain);


    const STATE_UNLOADED = 0;
    const STATE_STOPPED = 1;
    const STATE_PLAYING = 2;
    let oldPlaybackState = STATE_UNLOADED;
    let playbackState = STATE_UNLOADED;
    let currentTrack = null;
    let trackChanged = false;
    function AnimState(divElement, mainElement, extraElement, mainElementStyle) {
        this.divElement = divElement;
        this.mainElement = mainElement;
        this.extraElement = extraElement;
        this.mainElementStyle = mainElementStyle;
        this.offset = 0.0; // px
        this.speed = 25.0; // px/s
        this.wait = 2.0; // seconds
        this.start = undefined;
        this.lastTime = undefined;
        this.inProgress = false;
        this.animStopped = false;

        this.animStep = function (currentTime) {
            // early exit so we don't update anything by accident if animation should be over
            if (this.inProgress == false) {
                return;
            }

            if (this.start === undefined) {
                this.start = currentTime;
                this.lastTime = currentTime;
            }

            let deltaTime = (currentTime - this.lastTime) / 1000.0; // ms -> s
            let totalTime = (currentTime - this.start) / 1000.0; // ms -> s

            // only start scrolling when we waited a bit
            if (totalTime > this.wait) {
                this.offset -= deltaTime * this.speed;
                if (this.offset < (-1 * (this.mainElement.offsetWidth + parseInt(this.mainElementStyle.marginRight, 10)))) {
                    // scroll finished, restart animation
                    this.offset = 0.0;
                    this.start = currentTime;
                }
                this.divElement.style.transform = 'translateX(' + this.offset + 'px)';
            }

            this.lastTime = currentTime;
            window.requestAnimationFrame(this.animStep.bind(this));
        }

        this.updateElements = function (newContent) {
            this.mainElement.innerHTML = newContent;
            if (this.mainElement.offsetWidth > window.innerWidth) {
                this.extraElement.innerHTML = newContent;
            } else {
                this.extraElement.innerHTML = "";
            }
        }

        this.checkIfAnimNeeded = function () {
            if (this.inProgress && this.mainElement.offsetWidth <= window.innerWidth) {
                // shut down unneeded animation
                this.inProgress = false;
                this.divElement.style.transform = 'translateX(0px)';
                return;
            }

            this.start = undefined;
            this.offset = 0.0;
            this.divElement.style.transform = 'translateX(0px)';

            if (this.mainElement.offsetWidth > window.innerWidth) {
                this.inProgress = true;
                window.requestAnimationFrame(this.animStep.bind(this));
            }
        }
    }

    let titleAnimState = new AnimState(title, subTitleMain, subTitleExtra, subTitleMainStyle);
    let artistsAnimState = new AnimState(artists, subArtistsMain, subArtistsExtra, subArtistsMainStyle);
    let labelAnimState = new AnimState(label, subLabelMain, subLabelExtra, subLabelMainStyle);

    function update() {
        if (playbackState == STATE_PLAYING) {
            titleAnimState.updateElements(currentTrack.Title);
            artistsAnimState.updateElements(currentTrack.Artists);
            labelAnimState.updateElements(currentTrack.Label);
        } else if (playbackState == STATE_STOPPED) {
            titleAnimState.updateElements("Paused");
            artistsAnimState.updateElements("");
            labelAnimState.updateElements("");
        } else if (playbackState == STATE_UNLOADED) {
            titleAnimState.updateElements("");
            artistsAnimState.updateElements("");
            labelAnimState.updateElements("");
        } else {
            titleAnimState.updateElements("INVALID STATE");
            artistsAnimState.updateElements("This should not happen");
            labelAnimState.updateElements("[definitely shouldn't]");
        }

        if (trackChanged || (oldPlaybackState != playbackState)) {
            trackChanged = false;
            titleAnimState.checkIfAnimNeeded();
            artistsAnimState.checkIfAnimNeeded();
            labelAnimState.checkIfAnimNeeded();
        }
    }

    const serverAddress = getMeta('serveraddress');
    printDebug(serverAddress);
    let socket = new WebSocket("ws://" + serverAddress + "/");
    socket.onopen = function (e) {
        printDebug(`Connected to server at ${serverAddress}`);
    }

    socket.onclose = function (event) {
        playbackState = STATE_UNLOADED;
        update();

        if (event.wasClean) {
            printDebug(`Connection closed cleanly`);
        } else {
            printDebug(`Connection died`);
        }
    }

    socket.onerror = function (error) {
        printDebug(`Error: ${error.message}`);
    }

    socket.onmessage = function (event) {
        try {
            let obj = JSON.parse(event.data);

            if (obj.Type != null) {
                if (obj.Type == "NowPlayingTrackChanged") {
                    currentTrack = obj;
                    trackChanged = true;
                } else if (obj.Type == "NowPlayingStateUpdate") {
                    oldPlaybackState = playbackState;
                    playbackState = obj.State;
                    update();
                }
            } else {
                printDebug(`Received unknown obj: ${obj}`);
            }
        } catch (error) {
            printDebug(`Error: ${error}`);
        }
    }
</script>
