<!DOCTYPE html>

<link href="https://fonts.googleapis.com/css2?family=Open+Sans" rel="stylesheet">

<style>
    html {
        font-family: 'Open Sans',Arial,sans-serif;
        font: 16px 'Open Sans';
    }

    body {
        background-color: rgba(0, 0, 0, 0);
        overflow: hidden;
        color: #ffffff;
    }

    #chat {
        overflow: hidden;
        position: absolute;
        bottom: 0;
        left: 0px;
        width: 100vw;
        padding-left: 2px;
        padding-right: 2px;
        white-space: normal;
        word-wrap: break-word;
        text-shadow: black 0px 0px 2px, black 0px 0px 2px, black 0px 0px 2px;
    }

    .chat-inline {
        display: inline;
    }

    .chat-line {
        line-height: 2rem;
    }

    .chat-text-fragment {
        vertical-align: baseline;
    }

    .chat-emote {
        position: relative;
        margin: -.5rem 0;
        vertical-align: middle;
    }
</style>

<div id="chat">
</div>

<script>
    const dbg = document.getElementById("debug");
    function printDebug(text) {
        if (dbg) {
            dbg.innerHTML += text + "<br />";
        }
        console.log(text);
    }

    const metadata = document.getElementsByTagName('meta');
    function getMeta(name) {
        for (let i = 0; i < metadata.length; ++i) {
            if (metadata[i].getAttribute('name') === name) {
                return metadata[i].getAttribute('content');
            }
        }
        return '';
    }

    const serverAddress = getMeta('serveraddress');
    const chat = document.getElementById('chat');
    printDebug(serverAddress);


    const TWITCH_EMOTE_URL_SCHEME = ["//static-cdn.jtvnw.net/emoticons/v2/", "/default/dark/1.0", "/default/dark/2.0", "/default/dark/3.0"];
    const FFZ_EMOTE_URL_SCHEME = ["//cdn.frankerfacez.com/emote/", "/1", "/2", "/4"];
    const SEVENTV_EMOTE_URL_SCHEME = ["//cdn.7tv.app/emote/", "/1x", "/2x", "/4x"];

    class Emote {
        constructor(source, id, width, height, from, to) {
            this.mSource = source;
            this.mID = id;
            this.mWidth = width;
            this.mHeight = height;
            this.mFrom = from;
            this.mTo = to;
        }
    }

    class Message {
        constructor(msg) {
            if (msg.Type != "TwitchIRCMessage")
                throw new TypeError("Invalid message type");

            this.mID = msg.MessageID;
            this.mUserID = msg.UserID;
            this.mColor = msg.Color;
            this.mNick = msg.Nick;
            this.mDisplayName = msg.DisplayName;
            this.mMessage = msg.Message;
            this.mEmotes = [];
            if (msg.Emotes != undefined) {
                msg.Emotes.forEach(function (e) {
                    e.Ranges.forEach(function (r) {
                        this.mEmotes.push(new Emote(e.Source, e.ID, e.Width, e.Height, r.From, r.To));
                    }, this);
                }, this);

                // reverse-sort the emotes, mostly because it's easier to go through
                // the message in reverse afterwards (less indexing/shifting magic)
                this.mEmotes.sort(function(a, b) {
                    if (a.mFrom < b.mFrom)
                        return 1;
                    else if (a.mFrom > b.mFrom)
                        return -1;
                    else
                        return 0;
                });
            }
        }
    }

    class MessageList {
        constructor() {
        }

        add(msgObj) {
            let lastMsg = new Message(msgObj);

            let nick = lastMsg.mDisplayName;
            if (nick == "")
                nick = lastMsg.mNick;

            let nickTextNode = document.createTextNode(nick);

            let nickNode = document.createElement("span");
            nickNode.style.color = lastMsg.mColor;
            nickNode.appendChild(nickTextNode);

            let colonNode = document.createElement("span");
            colonNode.appendChild(document.createTextNode(": "));

            let textNode = document.createElement("span");
            textNode.classList.add("chat-text-fragment");
            let textDataNode = document.createTextNode(`${lastMsg.mMessage}`);
            textNode.appendChild(textDataNode);

            // replace emote texts based on ranges with links to emotes
            console.log(lastMsg.mEmotes);
            if (lastMsg.mEmotes != undefined) {
                lastMsg.mEmotes.forEach(function (e) {
                    let scheme = undefined;
                    if (e.mSource == "Twitch") {
                        scheme = TWITCH_EMOTE_URL_SCHEME;
                    } else if (e.mSource == "FFZ") {
                        scheme = FFZ_EMOTE_URL_SCHEME;
                    } else if (e.mSource = "SevenTV") {
                        scheme = SEVENTV_EMOTE_URL_SCHEME;
                    } else {
                        printDebug("Invalid emote source - skipping");
                        return;
                    }
                    let url = scheme[0] + e.mID;
                    let img = document.createElement("img");
                    img.src = url + scheme[1];
                    img.srcset =
                        url + scheme[1] + " 1x, " +
                        url + scheme[2] + " 2x, " +
                        url + scheme[3] + " 4x";
                    img.classList.add("chat-emote");

                    let imgDiv = document.createElement("div");
                    imgDiv.classList.add("chat-inline");
                    imgDiv.appendChild(img.cloneNode());

                    let textRemainder = textDataNode.splitText(e.mFrom);
                    textRemainder.deleteData(0, e.mTo - e.mFrom + 1);
                    textNode.insertBefore(imgDiv, textRemainder);
                });
            }

            let newMsgNode = document.createElement("span");
            newMsgNode.setAttribute("msgid", lastMsg.mID);
            newMsgNode.setAttribute("msguser", lastMsg.mNick);
            newMsgNode.classList.add("chat-line");
            newMsgNode.appendChild(nickNode);
            newMsgNode.appendChild(colonNode);
            newMsgNode.appendChild(textNode);
            newMsgNode.appendChild(document.createElement("br"));

            chat.appendChild(newMsgNode);

            // TODO remove messages which exceed window height + backup height
            if (chat.childNodes.length > 30) {
                chat.removeChild(chat.firstChild);
            }
        }

        remove(msgObj) {
            let id = msgObj.MessageID;
            if (msgObj.MessageID == "") {
                printDebug("Cannot remove message - no msg id provided");
                return;
            }

            let msgNode = chat.querySelector(`[msgid="${id}"]`);
            printDebug(msgNode);
            msgNode.remove();
        }

        removeUser(msgObj) {
            let msgs = chat.querySelectorAll(`[msguser=${msgObj.Nick}]`);

            msgs.forEach(function(m) {
                m.remove();
            });
        }
    }

    let msgList = new MessageList();


    let socket = new WebSocket("ws://" + serverAddress);
    socket.onopen = function (e) {
        printDebug(`Connected to server at ${serverAddress}`);
    }

    socket.onclose = function (event) {
        if (event.wasClean) {
            printDebug(`Connection closed cleanly`);
        } else {
            printDebug(`Connection died: ${event.code} (${event.reason})`);
        }
    }

    socket.onerror = function (error) {
        printDebug(`Error: ${error.message}`);
    }

    socket.onmessage = function (event) {
        try {
            let obj = JSON.parse(event.data);

            if (obj.Type != null) {
                switch (obj.Type)
                {
                case "TwitchIRCMessage":
                    msgList.add(obj);
                    break;
                case "TwitchIRCClearChat":
                    msgList.removeUser(obj);
                    break;
                case "TwitchIRCClearMsg":
                    msgList.remove(obj);
                    break;
                }
            } else {
                printDebug(`Received unknown obj: ${obj}`);
            }
        } catch (error) {
            printDebug(`Error: ${error}`);
        }
    }

    // debugging
    //for (var i = 0; i < 20; ++i) {
    //    chat.innerHTML += "abcd: lazy fox jumps something idk<br />";
    //}
    //chat.innerHTML += "michakes: please don't play KH so you never understand that reference<br />";
    //chat.innerHTML += "michakes: chat is cut off on the right a little<br />";
    //chat.innerHTML += "onaku__: grinning_face_with_one_large_and_one_small_eye<br />";
    //chat.innerHTML += "michakes: If I wanted to have like, a hot key tied to an action, how would I do that without a stream deck/something comparable?<br />";
</script>
